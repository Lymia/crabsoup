declare _CRABSOUP_VERSION: string

-- Crabsoup Classes
declare class CompletedProcess end
declare class Environment end
declare class NodeRef end
declare class Process end
declare class Timezone end

-- Crabsoup IPC Classes
declare class PluginInstruction
    function is_exit(self): boolean
    function is_fail(self): boolean
    function get_message(self): string
end

-- Crabsoup APIs
declare Date: {
    Timezone: { [string]: Timezone, Local: Timezone, UTC: Timezone },
    rfc2822: string,
    rfc3339: string,
    iso8601: string,
    now_timestamp: () -> number,
    now_timestamp_frac: () -> number,
    now_format: (format: string?, tz: (Timezone | string)?) -> string,
    format: (time: number, format: string?, tz: (Timezone | string)?) -> string,
    to_timestamp: (time: string, format: (string | {string})?, tz: (Timezone | string)?) -> number,
    reformat: (time: string, from_format: (string | {string})?, to_format: string?, tz: (Timezone | string)?) -> number,
}
declare Digest: {
    md5: (string) -> string,
    sha1: (string) -> string,
    sha256: (string) -> string,
    sha512: (string) -> string,
    blake2s: (string) -> string,
    blake2b: (string) -> string,
}
declare Log: {
    error: <T>(...T) -> (),
    warn: <T>(...T) -> (),
    warning: <T>(...T) -> (),
    info: <T>(...T) -> (),
    debug: <T>(...T) -> (),
    trace: <T>(...T) -> (),
}

-- Process library
type CommandInfo = {
    [number]: string,
    shell: string?,
    current_directory: string?,
    env: { [string]: string }?,
    stdin: string?,
    capture_stdout: boolean?,
    capture_stdout: boolean?,
}
declare Process: {
    run: (CommandInfo) -> (),
    try_run: (CommandInfo) -> number,
    run_output: (CommandInfo) -> string,
    spawn: (CommandInfo) -> Process,
    is_completed: (Process) -> boolean,
    wait_on: (Process) -> CompletedProcess,
    status: (CompletedProcess) -> number,
    get_stdout: (CompletedProcess) -> string,
    get_stderr: (CompletedProcess) -> string,
}
declare Regex: {
    match: (string, string) -> string,
    find_all: (string, string) -> {string},
    replace: (string, string, string) -> string,
    replace_all: (string, string, string) -> string,
    split: (string, string) -> {string},
}

-- Plugin library
type RequireEnv = typeof(setmetatable(newproxy(), {}))
declare Plugin: {
    fail: <T>(T?) -> never,
    exit: <T>(T?) -> never,
    require_version: (version: string) -> (),
    soupault_version: () -> string,
    crabsoup_version: () -> string,

    -- Plugin API
    env_standalone: Environment,
    env_plugin: Environment,
    create_require_env: (sources_path: string, env: Environment) -> RequireEnv,
    load_plugin: (ctx: RequireEnv, name: string, source: string, allowed_globals: { string }?) -> (globals: { [string]: any }?) -> thread,
    require_add_preload: (ctx: RequireEnv, name: string, value: any) -> (),
    require_set_strict: (ctx: RequireEnv) -> (),
    create_require_func: (ctx: RequireEnv) -> (name: string) -> any,
}
declare require: (name: string) -> any
declare require_env: RequireEnv

-- String loading functions
declare function dofile(filename: string, mode: string?, env: { [string]: any }?): any
declare function load<A...>(src: string | () -> string, chunkname: string?, mode: string?, env: { [string]: any }?): (((A...) -> any)?, string?)
declare function loadstring<A...>(src: string, chunkname: string?, mode: string?, env: { [string]: any }?): (((A...) -> any)?, string?)
declare function loadfile<A...>(filename: string, mode: string?, env: { [string]: any }?): (((A...) -> any)?, string?)

-- Standard library extensions
declare string: {
    byte: (s: string, f: number?, t: number?) -> ...number,
    char: (...number) -> string,
    find: (s: string, p: string, init: number?, plain: boolean?) -> (number?, number?, ...string),
    format: (s: string, ...any) -> string,
    gmatch: (s: string, p: string) -> (() -> ...string?),
    gsub: (s: string, p: string, f: ((...string) -> (string | number | false | nil)) | { [string]: string } | string, number?) -> (string, number),
    len: (s: string) -> number,
    lower: (s: string) -> string,
    match: (s: string, p: string, init: number?) -> ...string?,
    rep: (s: string, n: number) -> string,
    reverse: (s: string) -> string,
    sub: (s: string, f: number, t: number?) -> string,
    upper: (s: string) -> string,
    split: (s: string, sep: string?) -> {string},
    pack: (f: string, ...any) -> string,
    packsize: (f: string) -> number,
    unpack: (f: string, s: string) -> ...any,

    -- Extended functions
    trim: (s: string) -> string,
    startswith: (s: string, prefix: string) -> boolean,
    endswith: (s: string, prefix: string) -> boolean,
}

declare math: {
    frexp: (n: number) -> (number, number),
    ldexp: (s: number, e: number) -> number,
    fmod: (x: number, y: number) -> number,
    modf: (n: number) -> (number, number),
    pow: (x: number, y: number) -> number,
    exp: (n: number) -> number,
    ceil: (n: number) -> number,
    floor: (n: number) -> number,
    abs: (n: number) -> number,
    sqrt: (n: number) -> number,
    log: (n: number, base: number?) -> number,
    log10: (n: number) -> number,
    rad: (n: number) -> number,
    deg: (n: number) -> number,
    sin: (n: number) -> number,
    cos: (n: number) -> number,
    tan: (n: number) -> number,
    sinh: (n: number) -> number,
    cosh: (n: number) -> number,
    tanh: (n: number) -> number,
    atan: (n: number) -> number,
    acos: (n: number) -> number,
    asin: (n: number) -> number,
    atan2: (y: number, x: number) -> number,
    min: (number, ...number) -> number,
    max: (number, ...number) -> number,
    pi: number,
    huge: number,
    randomseed: (seed: number) -> (),
    random: (number?, number?) -> number,
    sign: (n: number) -> number,
    clamp: (n: number, min: number, max: number) -> number,
    noise: (x: number, y: number?, z: number?) -> number,
    round: (n: number) -> number,

    -- Extended functions
    isnan: (n: number) -> boolean,
    isinf: (n: number) -> boolean,
    isfinite: (n: number) -> boolean,
}
